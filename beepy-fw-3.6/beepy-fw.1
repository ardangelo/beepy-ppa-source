.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Beepy Firmware" "" "" "" ""
.hy
.SH Beepy Firmware
.IP \[bu] 2
User Guide
.RS 2
.IP \[bu] 2
Flashing firmware directly
.IP \[bu] 2
Firmware update utility
.IP \[bu] 2
Working with the keyboard driver
.RE
.IP \[bu] 2
Developer Reference
.RS 2
.IP \[bu] 2
Building from source
.IP \[bu] 2
Key values
.IP \[bu] 2
Power draw readings
.IP \[bu] 2
Register reference
.RE
.SS User Guide
.PP
In the Beepy device, separate from the Raspberry Pi running Linux, there
is an RP2040 microcontroller chip.
This chip controls basic hardware input and output functions, including
keyboard and touchpad input.
The firmware discussed here runs directly on the RP2040.
It cooperates with the Beepy keyboard driver beepy-kbd to provide key
input and other functionality to Linux running on the Raspberry Pi.
.PP
See keyboard driver reference beepy-kbd for more information on keymaps.
.SS Flashing firmware directly
.PP
If you\[cq]re setting up a new Beepy device, it\[cq]s recommended to
flash the firmware directly from the latest firmware release.
.IP "1." 3
Download the latest firmware
image (https://github.com/ardangelo/beepberry-rp2040/releases/latest/download/i2c_puppet.uf2)
.IP "2." 3
Turn the power switch off.
With the device facing up, slide the power switch in the bottom-left
hand corner to the left.
.PP
[IMAGE: Diagram showing direction of power switch]
.IP "3." 3
Connect the Beepy to your computer via USB-C.
.IP "4." 3
Locate the \[lq]End Call\[rq] key.
It is the rightmost key on the top row of four function keys.
.IP "5." 3
While holding the \[lq]End Call\[rq] key, slide the power switch back on
to enter firmware flash mode.
In firmware flash mode, the LED will light up, and the Beepy will
present itself as a USB mass storage device on your computer.
.IP "6." 3
Copy the firmware image onto the presented drive just like a normal
file.
When copying is complete, Beepy will automatically flash and reboot with
the new firmware.
.PP
If you\[cq]re setting up a new device, you can proceed with the rest of
the steps in the quick start guide.
.SS Firmware update utility
.PP
Once you have an up-to-date firmware image installed, and your Linux
system configured, you can update firmware directly on the device using
firmware distribution packages.
When a new firmware image is released, there will be an update available
for this package, \f[V]beepy-fw\f[R].
Running \f[V]sudo apt-get upgrade\f[R] will upgrade this firmware
package.
Due to the way that package updates work, firmware updates must be
applied using an updater utility.
.PP
The package comes with two primary files, a copy of the new firmware,
and the firmware updater utility \f[V]update-beepy-fw\f[R].
Copies of new firmware are installed into the directory
\f[V]/usr/lib/beepy-firmware\f[R].
After updating the firmware package, apply the firmware update by
running \f[V]sudo beepy-firmware\f[R].
.PP
For example, if you have firmware 3.0 installed, and update the
\f[V]beepy-fw\f[R] package to version 3.1, running the firmware updater
utility will look like this:
.IP
.nf
\f[C]
$ sudo update-beepy-fw

Beepy firmware updater
Installed firmware: 3.0
Newer firmware in /usr/lib/beepy-firmware:
[ 0] 3.1: beepy_3.1.hex
Enter number of newer firmware to install: 
\f[R]
.fi
.PP
In this case, you would want to type \f[V]0\f[R], then press
\f[V]Enter\f[R] to install version 3.1:
.IP
.nf
\f[C]
Enter number of newer firmware to install: 0
Installing /usr/lib/beepy-firmware/beepy_3.1.hex...
Update applied. Please wait until system powers back on in 30 seconds
\f[R]
.fi
.PP
After a successful firmware install, the system will shut down and apply
the firmware update.
Please wait until the update is installed and for the system to reboot
automatically.
There will be a delay of 30 seconds between the shutdown of the
Raspberry Pi and reboot to apply the firmware.
.PP
If the firmware cannot be written, the update will fail and new firmware
will not be applied.
But if you do get into a state with a broken firmware, you can always
follow the steps listed above in the section Flashing firmware directly
to reset or update the firmware.
.PP
If your firmware version is up to date, running \f[V]beepy-firmware\f[R]
will report that there are no newer versions available to install:
.IP
.nf
\f[C]
Beepy firmware updater
Installed firmware: 3.1
Newer firmware in /usr/lib/beepy-firmware:
    (None found)
\f[R]
.fi
.SS Working with the keyboard driver
.PP
When new functionality is added to the Beepy keyboard driver, there may
be a corresponding update to the firmware as well.
However, the keyboard driver will automatically check the installed
firmware version.
If there is a hard incompatibility, the installation of the keyboard
driver will fail:
.IP
.nf
\f[C]
error: driver requires firmware version 3.1
    (firmware has version 3.0)
update the beepy-fw package and run
    /sbin/update-beepy-fw
or manually install the firmware release from
    https://github.com/ardangelo/beepberry-rp2040/releases/latest
\f[R]
.fi
.PP
In this case, update the \f[V]beepy-fw\f[R] driver and run
\f[V]sudo update-beepy-fw\f[R] (see Firmware update utility), or
manually flash the updated firmware release (see Flashing firmware
directly).
.SS Developer Reference
.PP
This section is intended for developers to reference for working
directly with the firmware over I2C, at a lower level than the keyboard
driver.
For changing firmware settings from Linux through control files, see the
keyboard driver reference beepy-kbd.
.PP
This firmware is based off of the \f[V]i2c_puppet\f[R] firmware for
keyboard interaction and communication.
It adds several Beepy-specific features and improvements, including
sticky modifier keys, real-time-clock support, self-update capability,
deep sleep mode, and touchpad tuning.
.PP
Original readme for \f[V]i2c_puppet\f[R] including wiring and USB
reference:
.PP
https://github.com/solderparty/i2c_puppet/blob/main/README.md
.SS Building from source
.PP
The code depends on the Raspberry Pi Pico SDK, which is added as a
submodule.
You can either perform a recursive submodule init, or rather follow
these steps in the root of the repository:
.IP
.nf
\f[C]
cd 3rdparty/pico-sdk
git submodule update --init
cd 3rdparty/pico-flashloader
git submodule update --init
cd 3rdparty/pico-extras
git submodule update --init
\f[R]
.fi
.PP
Run \f[V]cmake\f[R] to build the firmware:
.IP
.nf
\f[C]
mkdir build
cd build
cmake -DPICO_BOARD=beepy ..
make
\f[R]
.fi
.PP
In the \f[V]build\f[R] directory, you will find the files
\f[V]i2c_puppet.uf2\f[R] and \f[V]app/firmware.hex\f[R].
The primary firmware file is \f[V]i2c_puppet.uf2\f[R], that can be
flashed directly over USB.
\f[V]app/firmware.hex\f[R] is an Intel HEX encoded firmware file that
can be applied on-device after converting line format to Unix and
prepending a firmware header:
.IP
.nf
\f[C]
cp app/firmware.hex beepy.hex
dos2unix beepy.hex
sed -i \[aq]1s;\[ha];+Beepy dev build\[rs]n;\[aq] beepy.hex
cat beepy.hex | sudo tee /sys/firmware/beepy/update_fw
\f[R]
.fi
.PP
See keyboard driver reference beepy-kbd for more information on using
\f[V]/sys/firmware/beepy/update_fw\f[R].
.SS Key values
.PP
Firmware has been updated to use BB10-style sticky modifier keys.
It has a corresponding kernel module that has been updated to read
modifier fields over I2C.
.PP
Holding a modifier key (shift, physical alt, Symbol) while typing an
alpha keys will apply the modifier to all alpha keys until the modifier
is released.
.PP
One press and release of the modifier will enter sticky mode, applying
the modifier to the next alpha key only.
If the same modifier key is pressed and released again in sticky mode,
it will be canceled.
.PP
Call is mapped to Control.
The Berry button is mapped to \f[V]KEY_PROPS\f[R].
Clicking the touchpad button is mapped to \f[V]KEY_COMPOSE\f[R].
Back is mapped to Escape.
End Call is not sent as a key, but holding it will still trigger the
power-off routine.
Symbol is mapped to AltGr (Right Alt).
.PP
Physical alt does not send an actual Alt key, but remaps the output
scancodes to the range 135 to 161 in QWERTY order.
This should be combined with a keymap for proper symbol output.
This allows symbols to be customized without rebuilding the firmware, as
well as proper use of the actual Alt key.
.PP
See keyboard driver reference beepy-kbd for more information on keymaps.
.SS Power draw readings
.PP
Approximate power draw readings, obtained using a USB-C power meter, in
amps.
.IP
.nf
\f[C]
\&.000 Power switch off

\&.50 Pi booting
\&.25 Pi idle, wireless connected, keyboard backlight full
\&.20 Pi idle, wireless connected, keyboard backlight off
\&.09 Pi shut down from command line (Pi pin still powered)
\&.025 Pi pin unpowered, no deep sleep
\&.005 Pi pin unpowered, deep sleep

\&.027 Backlight brightness off
\&.030 Backlight brightness dim
\&.053 Backlight brightness half
\&.079 Backlight brightness full

\&.030 Touchpad disabled
\&.031 Touchpad enabled
\f[R]
.fi
.SS Register reference
.PP
The device uses I2C slave interface to communicate, the address can be
configured in \f[V]app/config/conf_app.h\f[R], the default is
\f[V]0x1F\f[R].
.PP
You can read the values of all the registers, the number of returned
bytes depends on the register.
It\[cq]s also possible to write to the registers, to do that, apply the
write mask \f[V]0x80\f[R] to the register ID (for example, the backlight
register \f[V]0x05\f[R] becomes \f[V]0x85\f[R]).
.PP
Some registers are read-only or write-only.
For read-only registers, writes are discarded.
For write-only registers, arbitrary byte is returned.
.SS \f[V]0x01\f[R] \f[V]REG_ID_VER\f[R]
.PP
Read-only, 1 byte.
.PP
The first nibble contains the major version and the second nibble
contains the minor version of the firmware.
.SS \f[V]0x02\f[R] \f[V]REG_ID_CFG\f[R]
.PP
Read-write, 1 byte.
.PP
Bitmap of various settings that can be changed to customize the behavior
of the firmware.
.PP
See \f[V]REG_CF2\f[R] for additional settings.
.IP \[bu] 2
Bit \f[V]7\f[R] \f[V]CFG_USE_MODS\f[R]: deprecated, unused
.IP \[bu] 2
Bit \f[V]6\f[R] \f[V]CFG_REPORT_MODS\f[R]: deprecated, unused
.IP \[bu] 2
Bit \f[V]5\f[R] \f[V]CFG_PANIC_INT\f[R]: unused
.IP \[bu] 2
Bit \f[V]4\f[R] \f[V]CFG_KEY_INT\f[R]: Interrupt when a key is pressed
.IP \[bu] 2
Bit \f[V]3\f[R] \f[V]CFG_NUMLOCK_INT\f[R]: Interrupt when numlock is
pressed
.IP \[bu] 2
Bit \f[V]2\f[R] \f[V]CFG_CAPSLOCK_INT\f[R]: Interrupt when capslock is
pressed
.IP \[bu] 2
Bit \f[V]1\f[R] \f[V]CFG_OVERFLOW_INT\f[R]: Innterrupt when event queue
overflows
.IP \[bu] 2
Bit \f[V]0\f[R] \f[V]CFG_OVERFLOW_ON\f[R]: Overwrite oldest event when
overflow occurs
.PP
Defaut value: \f[V]CFG_OVERFLOW_INT | CFG_KEY_INT\f[R]
.SS \f[V]0x03\f[R] \f[V]REG_ID_INT\f[R]
.PP
Read-write, 1 byte.
.PP
On interrupt, this contains the cause.
.IP \[bu] 2
Bit \f[V]7\f[R] Unused
.IP \[bu] 2
Bit \f[V]6\f[R] \f[V]INT_TOUCH\f[R] Generated by trackpad motion
.IP \[bu] 2
Bit \f[V]5\f[R] \f[V]INT_GPIO\f[R] Generated by input GPIO changing
level
.IP \[bu] 2
Bit \f[V]4\f[R] \f[V]INT_PANIC\f[R] Unused
.IP \[bu] 2
Bit \f[V]3\f[R] \f[V]INT_KEY\f[R] Generated by a key press
.IP \[bu] 2
Bit \f[V]2\f[R] \f[V]INT_NUMLOCK\f[R] Generated by Num Lock
.IP \[bu] 2
Bit \f[V]1\f[R] \f[V]INT_CAPSLOCK\f[R] Generated by Caps Lock
.IP \[bu] 2
Bit \f[V]0\f[R] \f[V]INT_OVERFLOW\f[R] Generated by FIFO overflow
.PP
After reading this register, write \f[V]0x00\f[R] to reset it.
.PP
For \f[V]INT_GPIO\f[R], check \f[V]REG_GIN\f[R] to see which GPIO
triggered the interrupt.
The GPIO interrupt must first be enabled in \f[V]REG_GIC\f[R].
.SS \f[V]0x04\f[R] \f[V]REG_ID_KEY\f[R]
.PP
Read-only, 1 byte.
.PP
Contains FIFO status and modifier key status.
.IP \[bu] 2
Bit \f[V]7\f[R] Unused
.IP \[bu] 2
Bit \f[V]6\f[R] \f[V]KEY_NUMLOCK\f[R] Num Lock enabled?
.IP \[bu] 2
Bit \f[V]5\f[R] \f[V]KEY_CAPSLOCK\f[R] Caps Lock enabled?
.IP \[bu] 2
Bits \f[V]0-4\f[R] \f[V]KEY_COUNT\f[R] Unread FIFO event count
.SS \f[V]0x05\f[R] \f[V]REG_ID_BKL\f[R]
.PP
Read-write, 1 byte.
.PP
Set keyboard backlight brightness from \f[V]0x00\f[R] for off to
\f[V]0xff\f[R] for full brightness.
Full brightness draws approximately 25% more power on an idle Raspberry
Pi (see Power draw readings), so a lower setting is recommended.
.SS \f[V]0x06\f[R] \f[V]REG_ID_DEB\f[R]
.PP
Unimplemented, 1 byte.
.PP
Keyboard debounce setting.
.SS \f[V]0x07\f[R] \f[V]REG_ID_FRQ\f[R]
.PP
Unimplemented, 1 byte.
.PP
Keyboard poll frequency.
.SS \f[V]0x08\f[R] \f[V]REG_ID_RST\f[R]
.PP
Read-write, 1 byte.
.PP
Access will cause RP2040 to reset.
.SS \f[V]0x09\f[R] \f[V]REG_ID_FIF\f[R]
.PP
Read-only, 2 bytes.
.PP
Return topmost event in FIFO.
First byte contains key scancode.
Second byte contains key state:
.IP \[bu] 2
\f[V]0\f[R] \f[V]KEY_STATE_IDLE\f[R]
.IP \[bu] 2
\f[V]1\f[R] \f[V]KEY_STATE_PRESSED\f[R]
.IP \[bu] 2
\f[V]2\f[R] \f[V]KEY_STATE_HOLD\f[R]
.IP \[bu] 2
\f[V]3\f[R] \f[V]KEY_STATE_RELEASED\f[R]
.IP \[bu] 2
\f[V]4\f[R] \f[V]KEY_STATE_LONG_HOLD\f[R]
.SS \f[V]0x0A\f[R] \f[V]REG_ID_BK2\f[R]
.PP
Unimplemented, 1 byte.
.PP
Secondary backlight control.
.SS \f[V]0x0B\f[R] \f[V]REG_ID_DIR\f[R]
.PP
Read-write, 1 byte.
.PP
Cnotrols direction of the GPIO expander pins, each bit corresponding to
one pin.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
Bit set to \f[V]1\f[R] configures pin as input, bit set to \f[V]0\f[R]
configures pin as output.
.PP
Default value: \f[V]0xFF\f[R] (all pins configured as input)
.SS \f[V]0x0C\f[R] \f[V]REG_ID_PUE\f[R]
.PP
Read-write, 1 byte.
.PP
If a GPIO pin is configured as an input using \f[V]REG_DIR\f[R], an
optional pull-up/pull-down can be enabled.
If pin is configured as output, its bit in this register has no effect.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
Bit set to \f[V]1\f[R] enables input pull for that pin, bit set to
\f[V]0\f[R] disables input pull.
.PP
The direction of the pull is set in \f[V]REG_PUD\f[R].
.PP
Default value: 0 (all pulls disabled)
.SS \f[V]0x0D\f[R] \f[V]REG_ID_PUD\f[R]
.PP
Read-write, 1 byte.
.PP
If a GPIO pin is configured as an input using \f[V]REG_DIR\f[R], an
optional pull-up/pull-down can be enabled.
If pin is configured as output, its bit in this register has no effect.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
Bit set to \f[V]1\f[R] sets input pull to pull-up for that pin, bit set
to \f[V]0\f[R] sets input pull to pull-down.
.PP
Default value: \f[V]0xFF\f[R] (all pulls set to pull-up, if enabled in
\f[V]REG_PUE\f[R] and set to input in \f[V]REG_DIR\f[R])
.SS \f[V]0x0E\f[R] \f[V]REG_ID_GIO\f[R]
.PP
Read-write, 1 byte.
.PP
Contains the values of the GPIO Expander pins, each bit corresponding to
one pin.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
If a pin is configured as an output in \f[V]REG_DIR\f[R], writing to
this register will change the value of that pin.
.PP
Reading from this register returns the value for both input and output
pins.
.SS \f[V]0x0F\f[R] \f[V]REG_ID_GIC\f[R]
.PP
Read-write, 1 byte.
.PP
If a GPIO pin is configured as an input using \f[V]REG_DIR\f[R], an
optional interrupt on value change can be enabled.
If pin is configured as output, its bit in this register has no effect.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
Bit set to \f[V]1\f[R] triggers interrupt on value change, bit set to
\f[V]0\f[R] disables interrupt.
.PP
On interrupt, GPIO that triggered the interrupt can be determined by
reading \f[V]REG_GIN\f[R].
Additionally, the \f[V]INT_GPIO\f[R] bit will be set in
\f[V]REG_INT\f[R].
.PP
Default value: \f[V]0x00\f[R]
.SS \f[V]0x10\f[R] \f[V]REG_ID_GIN\f[R]
.PP
Read-only, 1 byte.
.PP
On interrupt, this register contains which GPIO pin caused the
interrupt, each bit corresponding to one pin.
.PP
The assignment of pin to MCU depends on the board, see
\f[V]boards/beepy.h\f[R] for the assignments.
.PP
After reading, reset it to \f[V]0x00\f[R].
.SS \f[V]0x11\f[R] \f[V]REG_ID_HLD\f[R]
.PP
Read-write, 1 byte.
.PP
Sets time threshold for \[lq]press and hold\[rq] key state, in units of
10ms.
.PP
When a key is held for longer than this time, a key hold event is
generated and enqueued into the FIFO event queue.
.PP
Default value: 30 (300ms)
.SS \f[V]0x12\f[R] \f[V]REG_ID_ADR\f[R]
.PP
Read-write, 1 byte.
.PP
Device\[cq]s primary I2C bus address.
On write, applies address change immediately.
The next communication must be performed on the new address.
Not saved after a reset.
.PP
Default value: \f[V]0x1F\f[R]
.SS \f[V]0x13\f[R] \f[V]REG_ID_IND\f[R]
.PP
Read-write, 1 byte.
.PP
Sets time for which the INT/IRQ pin is held LOW on interrupt, in units
of 1ms.
.PP
Default value: 1 (1ms)
.SS \f[V]0x14\f[R] \f[V]REG_ID_CF2\f[R]
.PP
Read-write, 1 byte.
.PP
Bitmap of various settings that can be changed to customize the behavior
of the firmware.
.PP
See \f[V]REG_CFG\f[R] for additional settings.
.IP \[bu] 2
\f[V]7\f[R] Unused
.IP \[bu] 2
\f[V]6\f[R] Unused
.IP \[bu] 2
\f[V]5\f[R] Unused
.IP \[bu] 2
\f[V]4\f[R] Unused
.IP \[bu] 2
\f[V]3\f[R] \f[V]CF2_AUTO_OFF\f[R] When driver state unloaded set to
unloaded, wait for \f[V]REG_ID_SHUTDOWN_GRACE\f[R] seconds, then enter
deep sleep
.IP \[bu] 2
\f[V]2\f[R] \f[V]CF2_USB_MOUSE_ON\f[R] Send trackpad events over USB
.IP \[bu] 2
\f[V]1\f[R] \f[V]CF2_USB_KEYB_ON\f[R] Send keyboard events over USB
.IP \[bu] 2
\f[V]0\f[R] \f[V]CF2_TOUCH_INT\f[R] Generate interrupt for trackpad
event
.PP
Default value: \f[V]CF2_TOUCH_INT | CF2_AUTO_OFF\f[R]
.SS \f[V]0x15\f[R] \f[V]REG_ID_TOX\f[R]
.PP
Read-only, 1 byte.
.PP
Trackpad X-axis position delta since the last time this register was
read.
Signed, in range[-128, 127].
Resets to 0 on read.
.PP
Recommended to read value when touch event received, or overflow may
occur.
.SS \f[V]0x16\f[R] \f[V]REG_ID_TOY\f[R]
.PP
Read-only, 1 byte.
.PP
Trackpad Y-axis position delta since the last time this register was
read.
Signed, in range[-128, 127].
Resets to 0 on read.
.PP
Recommended to read value when touch event received, or overflow may
occur.
.SS \f[V]0x17\f[R] \f[V]REG_ID_ADC\f[R]
.PP
Read-only, 2 bytes.
.PP
Raw battery level from ADC.
16-bit result:
.IP
.nf
\f[C]
(read(REG_ID_ADC)[1] << 8) | read(REG_ID_ADC)[0]
\f[R]
.fi
.SS \f[V]0x20\f[R] \f[V]REG_ID_LED\f[R]
.PP
Read-write, 1 byte.
.PP
Write the LED color registers before this register.
.IP \[bu] 2
\f[V]0x00\f[R] LED off
.IP \[bu] 2
\f[V]0x01\f[R] LED on
.IP \[bu] 2
\f[V]0x02\f[R] LED flashes
.IP \[bu] 2
\f[V]0x03\f[R] LED flashes until key is pressed
.PP
Mode 3, flash until key pressed, will overlay on top of an existing LED
setting.
For example, the following write sequence will set the LED to be solid
red, but with a blue flash.
Then, when a key is pressed, it will return to a solid red.
.IP
.nf
\f[C]
Set LED to solid red
REG_ID_LED_R <- 0xff
REG_ID_LED_G <- 0x00
REG_ID_LED_B <- 0x00
REG_ID_LED   <- 0x01

Set LED to flash blue until key pressed
REG_ID_LED_R <- 0x00
REG_ID_LED_G <- 0x00
REG_ID_LED_B <- 0xff
REG_ID_LED   <- 0x03
\f[R]
.fi
.SS \f[V]0x21\f[R] \f[V]REG_ID_LED_R\f[R]
.PP
Read-write, 1 byte.
.PP
Set LED red values unsigned in range [0, 255].
.PP
Color settings are applied after \f[V]REG_LED\f[R] is written.
.SS \f[V]0x22\f[R] \f[V]REG_ID_LED_G\f[R]
.PP
Read-write, 1 byte.
.PP
Set LED green values unsigned in range [0, 255].
.PP
Color settings are applied after \f[V]REG_LED\f[R] is written.
.SS \f[V]0x23\f[R] \f[V]REG_ID_LED_B\f[R]
.PP
Read-write, 1 byte.
.PP
Set LED blue values unsigned in range [0, 255].
.PP
Color settings are applied after \f[V]REG_LED\f[R] is written.
.SS \f[V]0x24\f[R] \f[V]REG_ID_REWAKE_MINS\f[R]
.PP
Read-write, 1 byte.
.PP
Write to shut down the Pi, then power-on in that many minutes.
Useful for polling services in conjunction with
\f[V]REG_ID_STARTUP_REASON\f[R], such as with the beepy-poll service.
.SS \f[V]0x25\f[R] \f[V]REG_ID_SHUTDOWN_GRACE\f[R]
.PP
Read-write, 1 byte.
.PP
Due to the Beepy hardware design, there is no way to reliably determine
the power state of the Pi.
To avoid powering off the Pi while it is still running, this register is
set to the number of seconds to wait between a shut down signal and Pi
power off.
This helps ensure that the Pi has time to process the power-off command
and to shut down cleanly.
.PP
Used for shutdown followed by rewake and entering deep sleep mode.
.PP
Default: 30 (30s)
.SS \f[V]0x26\f[R] \f[V]REG_ID_RTC_SEC\f[R]
.PP
Read-write, 1 byte.
.PP
Read to get the seconds value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x27\f[R] \f[V]REG_ID_RTC_MIN\f[R]
.PP
Read-write, 1 byte.
.PP
Read to get the minutes value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x28\f[R] \f[V]REG_ID_RTC_HOUR\f[R]
.PP
Read-write, 1 byte.
.PP
Read to get the hour value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x29\f[R] \f[V]REG_ID_RTC_MDAY\f[R]
.PP
Read-write, 1 byte.
.PP
Read to get the day-of-month value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x2A\f[R] \f[V]REG_ID_RTC_MON\f[R]
.PP
Read-write, 1 byte.
.PP
Read to get the month value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x2B\f[R] \f[V]REG_ID_RTC_YEAR\f[R]
.PP
Read-write, 1 byte.
.PP
Year value is expressed in years since 1900.
.PP
Read to get the year value from the real-time clock.
Write is committed after a write to \f[V]REG_ID_RTC_COMMIT\f[R].
.SS \f[V]0x2C\f[R] \f[V]REG_ID_RTC_COMMIT\f[R]
.PP
Write-only, 1 byte.
.PP
Write \f[V]1\f[R] to commit the values written to RTC registers to the
real-time clock.
Due to the Beepy hardware design, RTC settings are lost on power off of
the RP2040 via power switch, or when entering deep sleep.
.PP
The keyboard driver beepy-kbd will update the RP2040 RTC with network
time settings when available.
.SS \f[V]0x2D\f[R] \f[V]REG_ID_DRIVER_STATE\f[R]
.PP
Read-write, 1 byte.
.PP
Write \f[V]1\f[R] to indicate that the keyboard driver is loaded and
that shutdown commands will be read and processed.
The keyboard driver implementation will set this value to \f[V]1\f[R]
when the driver is loaded and \f[V]0\f[R] when unloaded.
.PP
In most cases, the driver is loaded on boot and unloaded during
shutdown.
For substantial power savings, the default-enabled
\f[V]CF2_AUTO_OFF\f[R] setting will trigger when \f[V]0\f[R] is written
to this register.
After a 30 second wait to allow for the driver to potentially be
reloaded, the RP2040 will send a shutdown signal to the Pi, wait for
\f[V]REG_ID_SHUTDOWN_GRACE\f[R] seconds, then power off the Pi and enter
deep sleep.
.PP
Default: \f[V]0\f[R]
.SS \f[V]0x2E\f[R] \f[V]REG_ID_STARTUP_REASON\f[R]
.PP
Read-only, 1 byte.
.PP
Contains the reason why the Pi was booted.
Useful for polling services in conjunction with
\f[V]REG_ID_REWAKE_MINS\f[R].
.IP \[bu] 2
\f[V]0\f[R] RP2040 initialized and booted Pi
.IP \[bu] 2
\f[V]1\f[R] Power button held to turn Pi back on
.IP \[bu] 2
\f[V]2\f[R] Rewake triggered from \f[V]REG_ID_REWAKE_MINS\f[R]
.IP \[bu] 2
\f[V]3\f[R] During rewake polling, \f[V]0\f[R] was written to
\f[V]REG_ID_REWAKE_MINS\f[R].
This allows the beepy-poll service to cancel the poll and proceeded with
a full boot
.SS \f[V]0x30\f[R] \f[V]REG_ID_UPDATE_DATA\f[R]
.PP
Read-write, 1 byte.
.PP
RP2040 firmware is loaded in two stages.
The first stage is a modified version of
pico-flashloader (https://github.com/rhulme/pico-flashloader).
It allows updates to be flashed to the second stage firmware while
booted.
The second stage is the actual Beepy firmware.
.PP
Reading \f[V]REG_ID_UPDATE_DATA\f[R] will return an update status code
.IP \[bu] 2
\f[V]0\f[R] \f[V]UPDATE_OFF\f[R] Update not in progress
.IP \[bu] 2
\f[V]1\f[R] \f[V]UPDATE_RECV\f[R] In the process of receiving an update
.IP \[bu] 2
\f[V]2\f[R] \f[V]UPDATE_FAILED\f[R] General update failure
.IP \[bu] 2
\f[V]3\f[R] \f[V]UPDATE_FAILED_LINE_OVERFLOW\f[R] Firmware line
overflowed buffer
.IP \[bu] 2
\f[V]4\f[R] \f[V]UPDATE_FAILED_FLASH_EMPTY\f[R] Firmware flash request
was empty
.IP \[bu] 2
\f[V]5\f[R] \f[V]UPDATE_FAILED_FLASH_OVERFLOW\f[R] Firmware overflows
allowed update region
.IP \[bu] 2
\f[V]6\f[R] \f[V]UPDATE_FAILED_BAD_LINE\f[R] Failed to parse line in
Intel HEX format
.IP \[bu] 2
\f[V]7\f[R] \f[V]UPDATE_FAILED_BAD_CHECKSUM\f[R] Failed checksum
.PP
Firmware updates are flashed by writing byte-by-byte to
\f[V]REG_UPDATE_DATA\f[R]:
.IP \[bu] 2
Header line beginning with \f[V]+\f[R] e.g.\ \f[V]+Beepy\f[R]
.IP \[bu] 2
Followed by the contents of an image in Intel HEX format
.PP
By default, \f[V]REG_UPDATE_DATA\f[R] will be set to
\f[V]UPDATE_OFF\f[R].
After writing, \f[V]REG_UPDATE_DATA\f[R] will be set to
\f[V]UPDATE_RECV\f[R] if more data is expected.
.PP
If the update completes successfully:
.IP \[bu] 2
\f[V]REG_UPDATE_DATA\f[R] will be set to \f[V]UPDATE_OFF\f[R]
.IP \[bu] 2
Shutdown signal will be sent to the Pi
.IP \[bu] 2
Delay to allow the Pi to cleanly shut down before poweroff (configurable
with \f[V]REG_SHUTDOWN_GRACE\f[R])
.IP \[bu] 2
Firmware is flashed and the system is reset
.PP
Please wait until the system reboots on its own before removing power.
.PP
If the update failed, \f[V]REG_UPDATE_DATA\f[R] will contain an error
code and the firmware will not be modified.
.PP
The header line \f[V]+...\f[R] will reset the update process, so an
interrupted or failed update can be retried by restarting the firmware
write.
.SS \f[V]0x40\f[R] \f[V]REG_ID_TOUCHPAD_REG\f[R]
.PP
Read-write, 1 byte.
.PP
To send or recieve data from the touchpad firmware, write the desired
touchpad register number.
Touchpad registers can be found in the ADBS A320
datasheet (https://www.mouser.com/datasheet/2/38/V02-1859EN+DS+ADBS-A320+16Nov2011-20613.pdf).
Then, read or write \f[V]REG_ID_TOUCHPAD_VAL\f[R].
.SS \f[V]0x41\f[R] \f[V]REG_ID_TOUCHPAD_VAL\f[R]
.PP
Read-write, 1 byte.
.PP
To send or recieve data from the touchpad firmware, write the desired
touchpad register number to \f[V]REG_ID_TOUCHPAD_REG\f[R].
Then, read or write this register.
.SS \f[V]0x42\f[R] \f[V]REG_ID_TOUCHPAD_MIN_SQUAL\f[R]
.PP
Read-write, 1 byte.
.PP
Reject touchpad input if surface quality as reported by touchpad sensor
is lower than this threshold.
.PP
Default: \f[V]16\f[R]
.SS \f[V]0x43\f[R] \f[V]REG_ID_TOUCHPAD_LED\f[R]
.PP
Read-write, 1 byte.
.PP
Touchpad LED power setting.
\[lq]High\[rq] is recommended for reliable input.
.IP \[bu] 2
\f[V]0x0\f[R] power medium
.IP \[bu] 2
\f[V]0x3\f[R] power high
.IP \[bu] 2
\f[V]0x5\f[R] power low
.PP
Default: \f[V]0x3\f[R] power high
